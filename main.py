import asyncio
from tqdm import tqdm
import chess
import random
from dotenv import load_dotenv
import concurrent.futures
from fire import Fire

from pydantic import BaseModel, Field
from pydantic_ai import Agent
from pydantic_ai.models.openai import OpenAIModel
import chess.svg

# Load environment variables from .env file
assert load_dotenv()

PROMPT_PLAYER_A = """
Your task is to make a plan to win a chess game against an opponent in a specified number of moves. You play as white and your opponent plays as black. 

# Input 
- FEN
- Legal moves
- Moves left
- Additional instructions, if any. (pay attention to them if they exist).

# Instructions:
1. Write a step-by-step plan as a list of moves (UCI), with reasoning for each step.
2. Analyze Black's best defenses.
3. Choose your next move from the legal moves.
4. If this is the last move, ensure your move delivers checkmate or stalemate. Only select from the legal moves provided.


# Output format
plan: (your plan as a list of moves and reasoning)
reasoning: (all your thinking and analysis)
move: (your next move in UCI format)

Example:
plan:
- Qf5-h7 (threatens mate)
- Qh7-h8# (checkmate)

reasoning:
Qf5-h7 threatens mate on h8. If Black does not defend, Qh7-h8 will be mate next move.

move: f5h7
"""


class PlayerAOutput(BaseModel):
    """
    The output model for Player A, which includes the move and reasoning.
    """

    plan: str = Field(
        description="A step-by-step plan as a list of moves (UCI), with reasoning for each step."
    )
    reasoning: str = Field(
        description="A brief explanation of the reasoning behind the chosen move."
    )
    move: str = Field(
        description="The best move to make in the current position, in UCI format (e.g., 'e2e4')."
    )


PROMPT_PLAYER_B = """
You are an expert chess analysis engine. Your task is to make a plan to win a chess game against an opponent in a specified number of moves. 

You play as white and your opponent plays as black. 

# Input 
- Current board position in FEN format.
- Legal moves (as a list of UCI strings).
- Number of moves left in the game (you need to win within this number of moves).
- Additional instructions, if any. (pay attention to them if they exist).
- plan: a plan generated by you during the previous move. Use it to infer your strategy for this move. The plan was generated before black played their last move.

Think step by step according to the following instructions:

# Instructions
Your objective is to win the game by making the best moves possible within the number of moves left in the game.

1. Inspect the black king position and the high values pieces you have. Note down any forcing moves you can make.
2. If no useful forcing moves are available, consider the following:
    1. If you can capture a high-value piece, do so.
    2. If you can create a threat against the black king, do so.
3. Generate a plan to win the game in the number of moves left. 

Once you are done with plan generation, proceed to the next section.

# Final output 
- all thinking about the plan should be done in the reasoning section.
- a brief summary of the plan should be provided in the plan section, formatted as a list of bullet points. Include both the current move and the plan for the next move.
- Once thinking is done, respond with your next move in UCI format (e.g., 'e2e4').
"""


class PlayerBOutput(BaseModel):
    """
    The output model for Player B, which includes the move, plan, and reasoning.
    """

    reasoning: str = Field(
        description="A brief explanation of the reasoning behind the chosen move."
    )
    move: str = Field(
        description="The best move to make in the current position, in UCI format (e.g., 'e2e4')."
    )
    plan: str = Field(
        description="A short plan for the next move, formatted as a list of bullet points."
    )


def random_player(board) -> str:
    """
    Given a board, get all of the legal moves in the current position.
    Then pick one of the legal moves at random and return it in UCI format.
    """
    legal_moves = list(board.legal_moves)
    if not legal_moves:
        raise ValueError("No legal moves available in the current position.")
    move = random.choice(legal_moves)
    return move.uci()


def play_game(
    fen: str,
    llm_player,
    move_limit: int = 2,
    valid_move: bool = False,
    use_plan: bool = False,
) -> str:
    """
    Play a game of chess against a random player.
    """

    board = chess.Board(fen)
    print(board.unicode())

    plan = None
    while not board.is_game_over():
        if move_limit <= 0:
            print("Move limit reached, ending game.")
            break

        legal_moves = [m.uci() for m in board.legal_moves]

        move = llm_player_move(
            llm_player, move_limit, board, legal_moves, valid_move, plan
        )
        plan = move.plan.strip() if use_plan else None

        board.push_uci(move.move)
        move_limit -= 1

        print("reasoning:", move.reasoning)
        print("LLM player move:", move.move)
        print(board.unicode())

        if board.is_game_over():
            break

        # random player makes a move
        random_move = random_player(board)
        board.push_uci(random_move)
        print(f"Random player move: {random_move}")
        print(board.unicode())

    # print the result for white and black
    if board.is_checkmate():
        if board.turn == chess.WHITE:
            print("Black wins by checkmate.")
        else:
            print("White wins by checkmate.")

    return board.result()


def llm_player_move(
    llm_player,
    move_limit,
    board,
    legal_moves,
    valid_move: bool = False,
    plan: str | None = None,
):
    additional_instructions = ""

    for _ in range(3):
        if plan:
            input_prompt = f"""
            =======CHESS GAME========
            - Current board position (FEN): {board.fen()}
            - LEGAL MOVES: {", ".join(legal_moves)}
            - MOVES LEFT: {move_limit}
            - CURRENT PLAN: {plan}
            =========================
            - ADDITIONAL INSTRUCTIONS: {additional_instructions}
            """
            move = asyncio.run(
                llm_player.run(input_prompt, model_settings={"temperature": 0.0})
            ).output

            plan = move.plan.strip()
        else:
            input_prompt = f"""
            =======CHESS GAME========
            - Current board position (FEN): {board.fen()}
            - LEGAL MOVES: {", ".join(legal_moves)}
            - MOVES LEFT: {move_limit}
            - ADDITIONAL INSTRUCTIONS: {additional_instructions}
            ========================="""
            move = asyncio.run(
                llm_player.run(input_prompt, model_settings={"temperature": 0.0})
            ).output

        llm_move = move.move.strip()

        if valid_move and (not llm_move or llm_move not in legal_moves):
            additional_instructions += f"- The move you proposed: {llm_move} is not a legal move. Please check the legal moves and try again.\n"
            print(f"LLM move {llm_move} is not legal, retrying.")
            continue

        if valid_move and move_limit == 1:
            temp_board = board.copy()
            temp_board.push_uci(llm_move)
            if not temp_board.is_checkmate():
                print(f"LLM move {llm_move} is not a checkmate or stalemate, retrying.")
                additional_instructions += f"- You proposed the move: {llm_move}, however a chess-verifier checked it and it is not a checkmate. Please pick a new move and be careful of hallucinations.\n"
            else:
                break
        else:
            break

    if (llm_move not in legal_moves) or (not llm_move):
        # play randomly
        print("No move provided by LLM, playing randomly.")
        move.move = random_player(board)
    return move


def main(
    number_of_trials: int = 5,
    parallel_games: int = 1,
    valid_move: bool = False,
    use_plan: bool = False,
) -> None:
    lm = OpenAIModel(
        "anthropic/claude-3-7-sonnet-20250219",
        provider="openrouter",
    )

    if use_plan:
        llm_player = Agent(
            model=lm,
            system_prompt=PROMPT_PLAYER_B,
            output_type=PlayerBOutput,
            name="Player B",
        )
    else:
        print("Using Player A prompt, no plan will be generated.")
        llm_player = Agent(
            model=lm,
            system_prompt=PROMPT_PLAYER_A,
            output_type=PlayerAOutput,
            name="Player A",
        )

    # from Siegbert Tarrasch vs. Max Kurschner, mate in 2
    # https://www.sparkchess.com/chess-puzzles/siegbert-tarrash-vs-max-kurschner.html
    move_limit, puzzle = (
        2,
        "r2qk2r/pb4pp/1n2Pb2/2B2Q2/p1p5/2P5/2B2PPP/RN2R1K1 w - - 1 0",
    )

    # mate in 3
    # https://www.sparkchess.com/chess-puzzles/dawid-przepiorka-vs-erich-eliskases.html
    # move_limit, puzzle =3,  2r3k1/p4p2/3Rp2p/1p2P1pK/8/1P4P1/P3Q2P/1q6 b - - 0 1

    if puzzle:
        if chess.Board(puzzle).turn == chess.BLACK:
            print("Puzzle is for black, flipping to white.")
            puzzle = chess.Board(puzzle).transform(chess.flip_vertical).fen()

    fen = puzzle.strip()
    count_wins = 0
    count_draws = 0

    def run_game(_):
        return play_game(
            fen,
            llm_player,
            move_limit,
            valid_move=valid_move,
            use_plan=use_plan,
        )

    with concurrent.futures.ThreadPoolExecutor(max_workers=parallel_games) as executor:
        results = list(
            tqdm(
                executor.map(run_game, range(number_of_trials)), total=number_of_trials
            )
        )

    for result in results:
        print(f"Result for puzzle {fen}: {result}")
        if result == "1-0":
            count_wins += 1
        elif result == "1/2-1/2":
            count_draws += 1

    print(f"\nResults for puzzle {fen}: {count_wins} wins, {count_draws} draws")


if __name__ == "__main__":
    Fire(main)
