import os
import asyncio
import random
import chess
from pydantic import BaseModel, Field
from pydantic_ai import Agent
from pydantic_ai.models.openai import OpenAIModel
from src.prompts import INSTRUCTIONS_COACH
from src.tools import (
    shallow_score_of_moves,
    score_move_against_stockfish,
    get_best_legal_counter_move_by_opponent,
    is_check,
)
from dotenv import load_dotenv

load_dotenv()

STOCKFISH_PATH = os.getenv("STOCKFISH_PATH")
model_name = os.getenv("MODEL_NAME")
lm = OpenAIModel(
    model_name=model_name,
    provider="openrouter",
)


class FeedbackModel(BaseModel):
    """
    Model for feedback on the player's move.
    This model can be extended to include additional fields as needed.
    """

    reasoning: str = Field(
        ..., description="reasoning behind the feedback on the player's move."
    )
    feedback: str = Field(
        ...,
        description="One sentence feedback on the player's move, including suggestions for improvement. The feedback should be concise and actionable and include the score. Also mentioning the player move and the best counter move by the opponent.",
    )


class FeedbackModelWithMove(FeedbackModel):
    """
    Model for feedback on the player's move, including the move itself.
    This model can be extended to include additional fields as needed.
    """

    move: str = Field(
        ...,
        description="A single move in UCI format (e.g., 'e2e4') that is suggested as a better alternative to the player's move.",
    )


class ChessBM(BaseModel):
    """
    Base model for chess players.
    This model can be extended to include additional fields as needed.
    """

    reasoning: str = Field(
        ..., description="A brief explanation of the reasoning behind the chosen move."
    )
    move: str = Field(..., description="The move in UCI format (e.g., 'e2e4').")


class LLMPlayer(Agent):
    """
    A player that uses a language model to decide on moves in a chess game.
    """

    def __init__(
        self,
        model,
        instructions: str,
        output_type: ChessBM | None = None,
        tools: list | None = None,
        **kwargs: dict,
    ):
        """
        Initialize the LLMPlayer with a model and instructions.
        :param model: The language model to use for generating moves.
        :param instructions: Instructions for the model to follow.
        :param output_type: The type of output expected from the model, defaults to ChessBM.
        :param kwargs: Additional keyword arguments for the Agent class.
        """
        output_type = output_type or ChessBM

        chess_tools = tools or []

        self.cache = {}

        super().__init__(
            model=model,
            instructions=instructions,
            output_type=output_type,
            tools=chess_tools,
            **kwargs,
        )

    def move(
        self,
        board: chess.Board,
        move_limit: int,
        additional_instructions: str | None = None,
        checkmate_retry: bool = False,
        model_settings: dict | None = None,
        max_tries: int = 2,
    ) -> ChessBM:
        """
        Generate a move for the given board using the language model.

        :param board: A chess.Board object representing the current position.
        :param move_limit: The number of moves left in the game.
        :param additional_instructions: Additional instructions for the model, if any.
        :param checkmate_retry: Whether to retry if the move does not result in checkmate.
        :param model_settings: Additional settings for the model, if any.
        :param max_tries: The maximum number of attempts to generate a valid move.
        :return: A ChessBM object."""
        model_settings = model_settings or {}
        legal_moves = [move.uci() for move in board.legal_moves]
        feedback = ""
        tries = 0
        moves_and_scores = []
        while tries < max_tries:
            input_prompt = self.create_instructions_str(
                board,
                legal_moves,
                move_limit,
                ((additional_instructions or "") + " " + (feedback or "")).strip(),
            )

            move = asyncio.run(
                self.run(
                    input_prompt,
                    model_settings=model_settings,
                )
            ).output

            print(f"Model generated move: {move.move} with reasoning: {move.reasoning}")
            print(
                f"Model plan: {move.plan if hasattr(move, 'plan') else 'No plan provided'}"
            )

            if not move:
                print("No move generated by the model, retrying.")
                tries += 1
                continue

            if not move.move:
                # get a random move if the model did not provide one
                move.move = random_player(board)
                move.plan = [move.move] if hasattr(move, "plan") else [move.move]

            if checkmate_retry:
                # check if move has an attribute plan
                new_feedback, score = self.check_if_plan_is_valid(
                    move.plan[0:1], board, move_limit
                )
                moves_and_scores.append((move, score))
                if new_feedback.feedback:
                    tries += 1
                    print(f"new_feedback.feedback: {new_feedback.feedback}")
                    feedback += f"feedback[{tries}] : {new_feedback.feedback}\n"
                    continue
                else:
                    break

        # return move with best score

        return (
            max(moves_and_scores, key=lambda x: x[1])[0] if moves_and_scores else None
        ), moves_and_scores

    def check_if_plan_is_valid(
        self, plan: list[str], board: chess.Board, move_limit: int
    ) -> tuple[FeedbackModel, float]:
        """
        Check if the proposed plan is valid by simulating the moves on the board. A plan is valid if
        it leads to checkmate in the specified number of moves.

        :param plan: A list of moves in UCI format (e.g., ['e2e4', 'e7e5']). Those are only the moves that the model has proposed.
        :param board: A chess.Board object representing the current position.
        :param move_limit: The number of moves left in the game.
        :return: None if the plan is valid, or a string with feedback if the plan is not valid.
        """
        # for each move in the plan, simulate the move on the board
        temp_board = board.copy()

        tactical_agent = Agent(
            model=lm, system_prompt=INSTRUCTIONS_COACH, output_type=FeedbackModel
        )

        record_best_engine_moves = []
        legal_moves = [m.uci() for m in temp_board.legal_moves]

        if plan[0] not in legal_moves:
            return (
                FeedbackModel(
                    reasoning="The first move in the plan is not legal.",
                    feedback=f"The move {plan[0]} is not valid. Please check your plan and ensure all moves are legal.",
                ),
                -10000.0,
            )

        if move_limit == 1:
            temp_board.push_uci(plan[0])
            if temp_board.is_checkmate():
                return (
                    FeedbackModel(
                        reasoning="The plan leads to checkmate in one move.",
                        feedback="",
                    ),
                    10000.0,
                )

            temp_board.pop()

        # score each move in the plan against Stockfish
        scores = {}
        for move in plan:
            score = score_move_against_stockfish(move, temp_board.fen())
            scores[move] = score

        print(f"Scores for the plan: {scores}")

        for i, move in enumerate(plan):
            if scores[move] > 0:
                # move is good, review the next
                continue

            try:
                legal_moves = [m.uci() for m in temp_board.legal_moves]
                top_legal_moves = self.get_top_legal_moves(temp_board)
                if move not in legal_moves:
                    feedback = asyncio.run(
                        tactical_agent.run(
                            str(
                                {
                                    "board_fen": board.fen(),
                                    "plan with chess engine scores": scores,
                                    "opponents_counter_moves": record_best_engine_moves,
                                    "legal_moves": top_legal_moves,
                                    "move_limit": move_limit,
                                    "move to review": move,
                                }
                            )
                        )
                    ).output
                    return feedback, scores[move]

                move_obj = chess.Move.from_uci(move)
                temp_board.push(move_obj)
                counter_move = get_best_legal_counter_move_by_opponent(temp_board)
                if counter_move:
                    counter_move_obj = chess.Move.from_uci(counter_move)
                    temp_board.push(counter_move_obj)
                    record_best_engine_moves.append(counter_move)

                # If it's the last move in the plan, check for checkmate
                if i == len(plan) - 1:
                    if not temp_board.is_checkmate():
                        feedback = asyncio.run(
                            tactical_agent.run(
                                str(
                                    {
                                        "board_fen": board.fen(),
                                        "plan with chess engine scores": scores,
                                        "opponents_counter_moves": record_best_engine_moves,
                                        "move_limit": move_limit,
                                        "move to review": move,
                                        "legal_moves": top_legal_moves,
                                    }
                                )
                            )
                        ).output
                        print(f"Feedback from tactical agent: {feedback}")
                        return feedback, scores[move]

                # If it's not the last move, get the best response from the opponent

            except ValueError as e:
                return f"Error processing move {move}: {str(e)}", 0.0

        return (
            FeedbackModel(
                reasoning="The plan is valid and leads to checkmate.",
                feedback="",
            ),
            10000.0,
        )

    def create_instructions_str(
        self,
        board: chess.Board,
        legal_moves: list[str],
        move_limit: int,
        additional_instructions: str | None = None,
    ) -> str:
        """
        Construct the input prompt for the LLM player.
        :param board: A chess.Board object representing the current position.
        :param legal_moves: A list of legal moves in the current position.
        :param move_limit: The number of moves left in the game.
        :param additional_instructions: Additional instructions for the model, if any.
        :return: The constructed input prompt as a string.
        """

        top_legal_moves = self.get_top_legal_moves(board)

        # - LEGAL MOVES: {", ".join(legal_moves)}
        prompt = f"""
        - BOARD DESCRIPTION: {board.fen()}
        - LEGAL MOVES: {", ".join(top_legal_moves)}
        - n: {move_limit}
        """

        if additional_instructions:
            prompt += f" - FEEDBACK: {additional_instructions}"

        return prompt

    def get_top_legal_moves(self, board: chess.Board) -> list[str]:
        return self.get_top_legal_moves_fallback(board)

    def get_top_legal_moves_fallback(self, board: chess.Board) -> list[str]:
        legal_moves = [move.uci() for move in board.legal_moves]
        scores = shallow_score_of_moves(legal_moves, board)
        top_indices = sorted(range(len(scores)), key=lambda i: scores[i], reverse=True)[
            :20
        ]
        top_legal_moves = [legal_moves[i] for i in top_indices]
        # shuffle to keep things fair
        random.shuffle(top_legal_moves)
        return top_legal_moves


class CorrectorLLMPlayer(LLMPlayer):
    """
    This player operates differently from the LLMPlayer.

    Instead of an agent generating a move and then getting feedback, we

    1. pick a random legal move
    2. get its score from Stockfish
    3. then we ask the LLM to provide feedback on the move and pick a better legal move if available.

    This strategy may lead to better performance in some cases, especially when the LLM is not able to generate a good move on its own.
    """

    def __init__(
        self,
        model,
        instructions: str = INSTRUCTIONS_COACH,
        output_type: FeedbackModelWithMove | None = None,
        **kwargs: dict,
    ):
        """
        Initialize the CorrectorLLMPlayer with a model and instructions.
        :param model: The language model to use for generating feedback.
        :param instructions: Instructions for the model to follow.
        :param output_type: The type of output expected from the model, defaults to FeedbackModel.
        :param kwargs: Additional keyword arguments for the Agent class.
        """
        output_type = output_type or FeedbackModel

        super().__init__(
            model=model,
            instructions=instructions,
            output_type=output_type,
            **kwargs,
        )

    def move(
        self,
        board: chess.Board,
        move_limit: int,
        additional_instructions: str | None = None,
        model_settings: dict | None = None,
        max_tries: int = 3,
        checkmate_retry: bool = False,
    ) -> tuple[ChessBM | FeedbackModelWithMove, dict[str, float]]:
        """
        Generate feedback for the given board using the language model.

        :param board: A chess.Board object representing the current position.
        :param move_limit: The number of moves left in the game.
        :param additional_instructions: Additional instructions for the model, if any.
        :param model_settings: Additional settings for the model, if any.
        :return: A tuple (ChessBM | FeedbackModelWithMove, dict[str, float]).
        """
        print("==========NEW MOVE========\n")
        print(f"Current board FEN: {board.fen()}")
        model_settings = model_settings or {}
        legal_moves = self.get_top_legal_moves(board)
        legal_move_properties = {
            move: {
                "is_check?": is_check(move, board.fen()),
            }
            for move in legal_moves
        }

        move = random.choice(legal_moves)
        feedback = ""
        moves_and_scores = {}
        old_move = None

        for try_num in range(max_tries):
            # get the score of the move
            str_move = move if isinstance(move, str) else move.move
            score = None
            counter_move = None

            if any(value > 0 for value in moves_and_scores.values()):
                # if we have already found a good move, we can skip the rest of the moves
                print("Done with the retries, we have already found a good move.")
                break

            if old_move and str_move == old_move:
                score = score_move_against_stockfish(str_move, board.fen())
                try:
                    board.push_uci(str_move)
                    counter_move = get_best_legal_counter_move_by_opponent(board)
                finally:
                    board.pop()

                moves_and_scores[str_move] = score
                print(f"Score for the move {str_move}: {score}")

            # create the input for the model
            # remove moves already considered
            legal_moves_input = {
                move: properties
                for move, properties in legal_move_properties.items()
                if move not in moves_and_scores
            }
            # black kings legal moves

            input_data = {
                "board_fen": board.fen(),
                "legal_moves": legal_moves_input,
                "move_limit": move_limit,
                "move": str_move,
                "counter_move": counter_move,
                "score": score,
                "feedback": feedback,
                "tries left": max_tries - try_num,
            }
            move = asyncio.run(
                self.run(
                    str(input_data),
                    model_settings=model_settings,
                )
            ).output

            if move.move in legal_moves:
                new_score = score_move_against_stockfish(move.move, board.fen())
                moves_and_scores[move.move] = new_score
                feedback += f"Tried move {move.move} with score: {new_score} and feedback: {move.feedback}\n"
                print(f"Model suggested move: {move.move} with score {new_score}")
                print(f"Model reasoning: {move.reasoning}")
                print("==========FEEDBACK========\n")
                print(f"Feedback:\n{feedback}")
                print("==========/FEEDBACK========\n")
                old_move = move.move
            else:
                print(f"Model suggested move: {move.move} is not legal.")
                feedback += f"Tried move {move.move}, but was not legal."
                old_move = None

        # pick the best move from the moves_and_scores
        if moves_and_scores:
            best_move = max(moves_and_scores, key=moves_and_scores.get)
            print(
                f"Best move after retries: {best_move} with score {moves_and_scores[best_move]}"
            )
            move = ChessBM(
                reasoning=move.reasoning,
                move=best_move,
            )
        else:
            print("No legal moves found after retries, falling back to random move.")
            move = ChessBM(
                reasoning="No legal moves found after retries, falling back to random move.",
                move=random_player(board),
            )

        return move, moves_and_scores


def random_player(board: chess.Board) -> str:
    """
    Given a board, get all of the legal moves in the current position.
    Then pick one of the legal moves at random and return it in UCI format.

    :param board: A chess.Board object representing the current position.
    :return: A string representing the chosen move in UCI format (e.g., 'e2e4').
    """
    legal_moves = list(board.legal_moves)
    if not legal_moves:
        raise ValueError("No legal moves available in the current position.")
    move = random.choice(legal_moves)
    return move.uci()
